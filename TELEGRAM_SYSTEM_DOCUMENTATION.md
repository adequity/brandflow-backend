# í…”ë ˆê·¸ë¨ ì•Œë¦¼ ì‹œìŠ¤í…œ ì™„ì „ ë¬¸ì„œ

## ğŸ“‹ ëª©ì°¨
1. [ì‹œìŠ¤í…œ ê°œìš”](#ì‹œìŠ¤í…œ-ê°œìš”)
2. [ì•„í‚¤í…ì²˜ êµ¬ì¡°](#ì•„í‚¤í…ì²˜-êµ¬ì¡°)
3. [ë°ì´í„°ë² ì´ìŠ¤ ëª¨ë¸](#ë°ì´í„°ë² ì´ìŠ¤-ëª¨ë¸)
4. [í•µì‹¬ ì„œë¹„ìŠ¤](#í•µì‹¬-ì„œë¹„ìŠ¤)
5. [API ì—”ë“œí¬ì¸íŠ¸](#api-ì—”ë“œí¬ì¸íŠ¸)
6. [ìŠ¤ì¼€ì¤„ëŸ¬ ë™ì‘ ë°©ì‹](#ìŠ¤ì¼€ì¤„ëŸ¬-ë™ì‘-ë°©ì‹)
7. [ë‚ ì§œ ì²˜ë¦¬ ë¡œì§](#ë‚ ì§œ-ì²˜ë¦¬-ë¡œì§)
8. [ì „ì²´ ì½”ë“œ](#ì „ì²´-ì½”ë“œ)

---

## ì‹œìŠ¤í…œ ê°œìš”

**BrandFlow í…”ë ˆê·¸ë¨ ì•Œë¦¼ ì‹œìŠ¤í…œ**ì€ ìº í˜ì¸ ë§ˆê°ì¼ì´ ì„ë°•í•  ë•Œ ì‚¬ìš©ìì—ê²Œ ìë™ìœ¼ë¡œ í…”ë ˆê·¸ë¨ ë©”ì‹œì§€ë¥¼ ë°œì†¡í•˜ëŠ” ì‹œìŠ¤í…œì…ë‹ˆë‹¤.

### ì£¼ìš” ê¸°ëŠ¥
- âœ… ì‚¬ìš©ìë³„ í…”ë ˆê·¸ë¨ ì„¤ì • ê´€ë¦¬
- âœ… ë§ˆê°ì¼ ì„ë°• ìë™ ì•Œë¦¼ (ì‚¬ìš©ì ì„¤ì • ê¸°ë°˜)
- âœ… ì•Œë¦¼ ì‹œê°„ ì»¤ìŠ¤í„°ë§ˆì´ì§• (ê¸°ë³¸: ì˜¤ì „ 9ì‹œ)
- âœ… ë§ˆê° ë©°ì¹  ì „ ì•Œë¦¼ ì„¤ì • (ê¸°ë³¸: 2ì¼)
- âœ… ì•Œë¦¼ ë°œì†¡ ë¡œê·¸ ê¸°ë¡
- âœ… í…ŒìŠ¤íŠ¸ ë©”ì‹œì§€ ì „ì†¡
- âœ… ê´€ë¦¬ì í†µê³„ ëŒ€ì‹œë³´ë“œ

### ì§€ì› ì‚¬ìš©ì ì—­í• 
- âŒ **CLIENT**: ì•Œë¦¼ ë¶ˆê°€ (ê³ ê°ì‚¬ëŠ” ëŒ€í–‰ì‚¬ ìš´ì˜ê³¼ ë¬´ê´€)
- âœ… **STAFF**: ë³¸ì¸ì´ ìƒì„±í•œ ìº í˜ì¸ì˜ ë§ˆê°ì¼ ì•Œë¦¼
- âœ… **TEAM_LEADER**: ë³¸ì¸ + íŒ€ì›ë“¤ì˜ ìº í˜ì¸ ë§ˆê°ì¼ ì•Œë¦¼
- âœ… **AGENCY_ADMIN**: íšŒì‚¬ ëª¨ë“  ìº í˜ì¸ ë§ˆê°ì¼ ì•Œë¦¼
- âœ… **SUPER_ADMIN**: ëª¨ë“  ìº í˜ì¸ ë§ˆê°ì¼ ì•Œë¦¼

---

## ì•„í‚¤í…ì²˜ êµ¬ì¡°

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     FastAPI Application                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Telegram Notification System                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚  API Endpoints   â”‚      â”‚   Scheduler      â”‚            â”‚
â”‚  â”‚                  â”‚      â”‚                  â”‚            â”‚
â”‚  â”‚ - ì„¤ì • CRUD      â”‚      â”‚ - 15ë¶„ë§ˆë‹¤ ì²´í¬  â”‚            â”‚
â”‚  â”‚ - í…ŒìŠ¤íŠ¸ ë°œì†¡    â”‚      â”‚ - ì•Œë¦¼ ì‹œê°„ í™•ì¸ â”‚            â”‚
â”‚  â”‚ - ë¡œê·¸ ì¡°íšŒ      â”‚      â”‚ - ìë™ ë°œì†¡      â”‚            â”‚
â”‚  â”‚ - í†µê³„           â”‚      â”‚ - ë¡œê·¸ ê¸°ë¡      â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚           â”‚                         â”‚                       â”‚
â”‚           â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                       â”‚
â”‚                    â–¼                                         â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                            â”‚
â”‚         â”‚   Telegram Service   â”‚                            â”‚
â”‚         â”‚                      â”‚                            â”‚
â”‚         â”‚ - send_message()     â”‚                            â”‚
â”‚         â”‚ - get_chat_info()    â”‚                            â”‚
â”‚         â”‚ - send_reminder()    â”‚                            â”‚
â”‚         â”‚ - send_test()        â”‚                            â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                            â”‚
â”‚                    â”‚                                         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
                     â–¼
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚  Telegram Bot API     â”‚
         â”‚  (api.telegram.org)   â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
                     â–¼
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚    User's Telegram    â”‚
         â”‚      Client App       â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### ì»´í¬ë„ŒíŠ¸ ì„¤ëª…

| ì»´í¬ë„ŒíŠ¸ | ì—­í•  | íŒŒì¼ ìœ„ì¹˜ |
|---------|------|----------|
| **API Endpoints** | í…”ë ˆê·¸ë¨ ì„¤ì • CRUD, í…ŒìŠ¤íŠ¸, í†µê³„ | `app/api/endpoints/telegram_settings.py` |
| **Scheduler** | ì£¼ê¸°ì ìœ¼ë¡œ ë§ˆê°ì¼ ì²´í¬ ë° ì•Œë¦¼ ë°œì†¡ | `app/services/telegram_scheduler.py` |
| **Telegram Service** | í…”ë ˆê·¸ë¨ API í˜¸ì¶œ ë¡œì§ | `app/services/telegram_service.py` |
| **Database Models** | ì„¤ì •, ë¡œê·¸ ì €ì¥ | `app/models/user_telegram_setting.py` |
| **Schemas** | Pydantic ê²€ì¦ ëª¨ë¸ | `app/schemas/telegram_setting.py` |
| **Date Utils** | ë‚ ì§œ íŒŒì‹± ë° ì•Œë¦¼ íŒë‹¨ | `app/utils/date_utils.py` |

---

## ë°ì´í„°ë² ì´ìŠ¤ ëª¨ë¸

### 1. UserTelegramSetting (ì‚¬ìš©ì í…”ë ˆê·¸ë¨ ì„¤ì •)

**í…Œì´ë¸”ëª…**: `user_telegram_settings`

```python
class UserTelegramSetting(Base, TimestampMixin):
    """ì‚¬ìš©ìë³„ í…”ë ˆê·¸ë¨ ì•Œë¦¼ ì„¤ì •"""
    __tablename__ = "user_telegram_settings"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False, unique=True)
    telegram_chat_id = Column(String(100), nullable=False, index=True)
    telegram_username = Column(String(100), nullable=True)

    # ì•Œë¦¼ ì„¤ì •
    is_enabled = Column(Boolean, default=True, nullable=False)
    days_before_due = Column(Integer, default=2, nullable=False)  # ë§ˆê°ì¼ ë©°ì¹  ì „ ì•Œë¦¼
    notification_time = Column(String(5), default="09:00", nullable=False)  # ì•Œë¦¼ ì‹œê°„ (HH:MM)

    # ë§ˆì§€ë§‰ ì•Œë¦¼ ê¸°ë¡
    last_notification_at = Column(DateTime, nullable=True)

    # ê´€ê³„
    user = relationship("User", back_populates="telegram_setting")
```

**ì»¬ëŸ¼ ì„¤ëª…**:
| ì»¬ëŸ¼ | íƒ€ì… | ì„¤ëª… | ê¸°ë³¸ê°’ |
|-----|------|------|-------|
| `id` | Integer | Primary Key | AUTO |
| `user_id` | Integer | ì‚¬ìš©ì ID (FK, UNIQUE) | - |
| `telegram_chat_id` | String(100) | í…”ë ˆê·¸ë¨ ì±„íŒ… ID | - |
| `telegram_username` | String(100) | í…”ë ˆê·¸ë¨ ì‚¬ìš©ìëª… (ì„ íƒ) | NULL |
| `is_enabled` | Boolean | ì•Œë¦¼ í™œì„±í™” ì—¬ë¶€ | true |
| `days_before_due` | Integer | ë§ˆê°ì¼ ë©°ì¹  ì „ ì•Œë¦¼ | 2 |
| `notification_time` | String(5) | ì•Œë¦¼ ì‹œê°„ (HH:MM) | "09:00" |
| `last_notification_at` | DateTime | ë§ˆì§€ë§‰ ì•Œë¦¼ ë°œì†¡ ì‹œê° | NULL |

### 2. TelegramNotificationLog (ì•Œë¦¼ ë°œì†¡ ë¡œê·¸)

**í…Œì´ë¸”ëª…**: `telegram_notification_logs`

```python
class TelegramNotificationLog(Base, TimestampMixin):
    """í…”ë ˆê·¸ë¨ ì•Œë¦¼ ë°œì†¡ ë¡œê·¸"""
    __tablename__ = "telegram_notification_logs"

    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    post_id = Column(Integer, ForeignKey("posts.id"), nullable=True)  # í…ŒìŠ¤íŠ¸ ë©”ì‹œì§€ëŠ” None ê°€ëŠ¥
    campaign_id = Column(Integer, ForeignKey("campaigns.id"), nullable=True)

    # ì•Œë¦¼ ì •ë³´
    notification_type = Column(String(50), default="due_date_reminder", nullable=False)
    message_content = Column(String(1000), nullable=False)
    telegram_chat_id = Column(String(100), nullable=False)

    # ë°œì†¡ ê²°ê³¼
    is_sent = Column(Boolean, default=False, nullable=False)
    sent_at = Column(DateTime, nullable=True)
    error_message = Column(String(500), nullable=True)
    telegram_message_id = Column(String(100), nullable=True)

    # ê´€ê³„
    user = relationship("User")
    post = relationship("Post")
    campaign = relationship("Campaign")
```

**ì»¬ëŸ¼ ì„¤ëª…**:
| ì»¬ëŸ¼ | íƒ€ì… | ì„¤ëª… |
|-----|------|------|
| `id` | Integer | Primary Key |
| `user_id` | Integer | ì‚¬ìš©ì ID (FK) |
| `post_id` | Integer | Post ID (FK, NULL ê°€ëŠ¥) |
| `campaign_id` | Integer | Campaign ID (FK, NULL ê°€ëŠ¥) |
| `notification_type` | String(50) | ì•Œë¦¼ íƒ€ì… (due_date_reminder, test_message) |
| `message_content` | String(1000) | ì „ì†¡ëœ ë©”ì‹œì§€ ë‚´ìš© |
| `telegram_chat_id` | String(100) | í…”ë ˆê·¸ë¨ ì±„íŒ… ID |
| `is_sent` | Boolean | ì „ì†¡ ì„±ê³µ ì—¬ë¶€ |
| `sent_at` | DateTime | ì „ì†¡ ì™„ë£Œ ì‹œê° |
| `error_message` | String(500) | ì—ëŸ¬ ë©”ì‹œì§€ (ì‹¤íŒ¨ ì‹œ) |
| `telegram_message_id` | String(100) | í…”ë ˆê·¸ë¨ ë©”ì‹œì§€ ID |

---

## í•µì‹¬ ì„œë¹„ìŠ¤

### 1. TelegramService (í…”ë ˆê·¸ë¨ API ì„œë¹„ìŠ¤)

**íŒŒì¼**: `app/services/telegram_service.py`

#### ì£¼ìš” ë©”ì„œë“œ

##### `send_message(chat_id, message, parse_mode, disable_web_page_preview)`
í…”ë ˆê·¸ë¨ ë©”ì‹œì§€ ì „ì†¡

**Parameters**:
- `chat_id` (str): í…”ë ˆê·¸ë¨ ì±„íŒ… ID
- `message` (str): ì „ì†¡í•  ë©”ì‹œì§€ ë‚´ìš©
- `parse_mode` (str): ë©”ì‹œì§€ í¬ë§· (ê¸°ë³¸: "HTML")
- `disable_web_page_preview` (bool): ë§í¬ ë¯¸ë¦¬ë³´ê¸° ë¹„í™œì„±í™” (ê¸°ë³¸: True)

**Returns**:
```python
{
    "success": True/False,
    "message_id": "123456",  # ì„±ê³µ ì‹œ
    "error": "error message",  # ì‹¤íŒ¨ ì‹œ
    "error_code": "error_code"  # ì‹¤íŒ¨ ì‹œ
}
```

##### `get_chat_info(chat_id)`
ì±„íŒ… ì •ë³´ ì¡°íšŒ (chat_id ìœ íš¨ì„± ê²€ì¦ìš©)

**Parameters**:
- `chat_id` (str): í…”ë ˆê·¸ë¨ ì±„íŒ… ID

**Returns**:
```python
{
    "success": True/False,
    "data": {...},  # ì„±ê³µ ì‹œ ì±„íŒ… ì •ë³´
    "error": "error message"  # ì‹¤íŒ¨ ì‹œ
}
```

##### `send_campaign_deadline_reminder(...)`
ìº í˜ì¸ ë§ˆê°ì¼ ì•Œë¦¼ ë©”ì‹œì§€ ì „ì†¡

**Parameters**:
- `chat_id` (str): í…”ë ˆê·¸ë¨ ì±„íŒ… ID
- `user_name` (str): ì‚¬ìš©ì ì´ë¦„
- `post_title` (str): ì‘ì—…ëª…
- `due_date` (str): ë§ˆê°ì¼
- `days_before` (int): ë©°ì¹  ì „ ì•Œë¦¼
- `work_type` (str, optional): ìƒí’ˆì¢…ë¥˜
- `product_name` (str, optional): ìƒí’ˆëª…

**ë©”ì‹œì§€ í˜•ì‹**:
```
ğŸš¨ ê¸´ê¸‰ - ìº í˜ì¸ ë§ˆê°ì¼ ì•Œë¦¼

ì•ˆë…•í•˜ì„¸ìš”, í™ê¸¸ë™ë‹˜!

ğŸ“ ì‘ì—…ëª…: ì¸ìŠ¤íƒ€ê·¸ë¨ í”¼ë“œ í¬ìŠ¤íŒ…
ğŸ“‹ ìƒí’ˆì¢…ë¥˜: ì¸í”Œë£¨ì–¸ì„œ
ğŸ”— ìƒí’ˆëª…: ë‚˜ì´í‚¤ ìš´ë™í™”
ğŸ“… ë§ˆê°ì¼: 2025-11-15 18:00
â°ë‚¨ì€ ì‹œê°„: 2ì¼

ë§ˆê°ì¼ì´ ë‹¤ê°€ì˜¤ê³  ìˆìŠµë‹ˆë‹¤. ì‘ì—… ì§„í–‰ ìƒí™©ì„ í™•ì¸í•´ ì£¼ì„¸ìš”!

BrandFlow ì•Œë¦¼ ì‹œìŠ¤í…œ
```

##### `send_test_message(chat_id, user_name)`
í…ŒìŠ¤íŠ¸ ë©”ì‹œì§€ ì „ì†¡

---

### 2. TelegramScheduler (ìŠ¤ì¼€ì¤„ëŸ¬)

**íŒŒì¼**: `app/services/telegram_scheduler.py`

#### ì£¼ìš” ë©”ì„œë“œ

##### `start()`
ìŠ¤ì¼€ì¤„ëŸ¬ ì‹œì‘ (ë°±ê·¸ë¼ìš´ë“œ ë£¨í”„)

**ë™ì‘**:
1. `self.running = True` ì„¤ì •
2. ë¬´í•œ ë£¨í”„ ì‹œì‘
3. 15ë¶„ë§ˆë‹¤ `check_and_send_notifications()` í˜¸ì¶œ
4. ì˜¤ë¥˜ ë°œìƒ ì‹œ 1ë¶„ í›„ ì¬ì‹œë„

##### `stop()`
ìŠ¤ì¼€ì¤„ëŸ¬ ì¤‘ì§€

##### `check_and_send_notifications()`
ë§ˆê°ì¼ ì„ë°• ì•Œë¦¼ í™•ì¸ ë° ì „ì†¡

**ë™ì‘ í”„ë¡œì„¸ìŠ¤**:
```
1. CLIENT ì—­í•  ì œì™¸í•œ í™œì„± ì‚¬ìš©ì ì¡°íšŒ
   â†“
2. ê° ì‚¬ìš©ìë³„ë¡œ ë£¨í”„:
   â”œâ”€ ì‚¬ìš©ìê°€ ìƒì„±í•œ ìº í˜ì¸ì˜ ë§ˆê°ì¼ ìˆëŠ” posts ì¡°íšŒ
   â”œâ”€ ê° postë³„ë¡œ ì•Œë¦¼ ì¡°ê±´ ì²´í¬:
   â”‚  â”œâ”€ ì˜¤ëŠ˜ ì´ë¯¸ ì•Œë¦¼ ë³´ëƒˆëŠ”ì§€ í™•ì¸ (ì¤‘ë³µ ë°©ì§€)
   â”‚  â”œâ”€ í˜„ì¬ ì‹œê°„ì´ ì•Œë¦¼ ì‹œê°„ëŒ€ì¸ì§€ í™•ì¸ (Â±2ì‹œê°„)
   â”‚  â””â”€ ë§ˆê°ì¼ê¹Œì§€ days_before_due ì´ë‚´ì¸ì§€ í™•ì¸
   â””â”€ ì¡°ê±´ ë§Œì¡± ì‹œ ì•Œë¦¼ ì „ì†¡
   â†“
3. ë¡œê·¸ ì €ì¥ (ì„±ê³µ/ì‹¤íŒ¨)
   â†“
4. last_notification_at ì—…ë°ì´íŠ¸
```

##### `get_user_posts_with_upcoming_deadlines(db, user_id, days_before)`
ì‚¬ìš©ìì˜ ë§ˆê°ì¼ ì„ë°• posts ì¡°íšŒ

**Parameters**:
- `db` (Session): ë°ì´í„°ë² ì´ìŠ¤ ì„¸ì…˜
- `user_id` (int): ì‚¬ìš©ì ID
- `days_before` (int): ë©°ì¹  ì „ ì•Œë¦¼ ì„¤ì •

**Returns**:
```python
[
    (post, campaign, days_left),  # Tuple[Post, Campaign, float]
    ...
]
```

**ë¡œì§**:
1. ì‚¬ìš©ìê°€ ìƒì„±í•œ ìº í˜ì¸ì˜ posts ì¡°íšŒ (due_date ìˆëŠ” ê²ƒë§Œ)
2. ê° postì˜ due_dateë¥¼ íŒŒì‹± (`parse_due_datetime`)
3. `should_send_telegram_notification()` í•¨ìˆ˜ë¡œ ì•Œë¦¼ ì¡°ê±´ íŒë‹¨
4. ì¡°ê±´ ë§Œì¡±í•˜ëŠ” postsë§Œ ë°˜í™˜

##### `send_deadline_notification(...)`
ë§ˆê°ì¼ ì•Œë¦¼ ì „ì†¡

**Parameters**:
- `db` (Session): ë°ì´í„°ë² ì´ìŠ¤ ì„¸ì…˜
- `user` (User): ì‚¬ìš©ì ê°ì²´
- `post` (Post): Post ê°ì²´
- `campaign` (Campaign): Campaign ê°ì²´
- `days_left` (float): ë‚¨ì€ ì¼ìˆ˜
- `telegram_setting` (UserTelegramSetting): í…”ë ˆê·¸ë¨ ì„¤ì •

**ë™ì‘**:
1. due_date íŒŒì‹± ë° í¬ë§·íŒ…
2. `telegram_service.send_campaign_deadline_reminder()` í˜¸ì¶œ
3. TelegramNotificationLog ìƒì„± ë° ì €ì¥
4. ì„±ê³µ ì‹œ `last_notification_at` ì—…ë°ì´íŠ¸

##### `is_notification_time(notification_time)`
í˜„ì¬ ì‹œê°„ì´ ì•Œë¦¼ ì‹œê°„ì¸ì§€ í™•ì¸

**ë¡œì§**:
- ì•Œë¦¼ ì‹œê°„ Â±2ì‹œê°„ ë²”ìœ„ ë‚´ì— ìˆìœ¼ë©´ True
- ì˜ˆ: ì•Œë¦¼ ì‹œê°„ 09:00 â†’ 07:00~11:00 ì‚¬ì´ë©´ True

---

## API ì—”ë“œí¬ì¸íŠ¸

**Router**: `/api/telegram-settings`

### 1. ì‚¬ìš©ì ì„¤ì • ê´€ë¦¬

#### `GET /my-setting`
í˜„ì¬ ì‚¬ìš©ìì˜ í…”ë ˆê·¸ë¨ ì„¤ì • ì¡°íšŒ

**Response**:
```json
{
  "id": 1,
  "user_id": 5,
  "telegram_chat_id": "123456789",
  "telegram_username": "john_doe",
  "is_enabled": true,
  "days_before_due": 2,
  "notification_time": "09:00",
  "last_notification_at": "2025-10-28T09:00:00",
  "created_at": "2025-10-01T10:00:00",
  "updated_at": "2025-10-28T09:00:00"
}
```

#### `POST /my-setting`
í…”ë ˆê·¸ë¨ ì„¤ì • ìƒì„± ë˜ëŠ” ì—…ë°ì´íŠ¸

**Request Body**:
```json
{
  "telegram_chat_id": "123456789",
  "telegram_username": "john_doe",
  "is_enabled": true,
  "days_before_due": 2,
  "notification_time": "09:00"
}
```

**Validation**:
- `telegram_chat_id`: ìˆ«ì ë˜ëŠ” @ë¡œ ì‹œì‘í•˜ëŠ” ë¬¸ìì—´
- `notification_time`: HH:MM í˜•ì‹ (00:00 ~ 23:59)
- `days_before_due`: 1 ~ 30 ì‚¬ì´

**Response**: ìƒì„±/ì—…ë°ì´íŠ¸ëœ ì„¤ì • ê°ì²´

#### `PUT /my-setting`
í…”ë ˆê·¸ë¨ ì„¤ì • ì—…ë°ì´íŠ¸

**Request Body** (ë¶€ë¶„ ì—…ë°ì´íŠ¸ ê°€ëŠ¥):
```json
{
  "is_enabled": false,
  "days_before_due": 3
}
```

#### `DELETE /my-setting`
í…”ë ˆê·¸ë¨ ì„¤ì • ì‚­ì œ

**Response**:
```json
{
  "message": "í…”ë ˆê·¸ë¨ ì„¤ì •ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤"
}
```

---

### 2. í…ŒìŠ¤íŠ¸ ë° ë¡œê·¸

#### `POST /test`
í…”ë ˆê·¸ë¨ í…ŒìŠ¤íŠ¸ ë©”ì‹œì§€ ì „ì†¡

**Request Body**:
```json
{
  "message": "í…ŒìŠ¤íŠ¸ ë©”ì‹œì§€ì…ë‹ˆë‹¤."
}
```

**Response** (ì„±ê³µ):
```json
{
  "success": true,
  "message": "í…ŒìŠ¤íŠ¸ ë©”ì‹œì§€ê°€ ì„±ê³µì ìœ¼ë¡œ ì „ì†¡ë˜ì—ˆìŠµë‹ˆë‹¤!",
  "telegram_message_id": "123456"
}
```

**Response** (ì‹¤íŒ¨):
```json
{
  "detail": "ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨: Invalid chat_id"
}
```

#### `GET /logs?limit=20&offset=0`
í˜„ì¬ ì‚¬ìš©ìì˜ í…”ë ˆê·¸ë¨ ì•Œë¦¼ ë¡œê·¸ ì¡°íšŒ

**Query Parameters**:
- `limit` (int): ì¡°íšŒí•  ë¡œê·¸ ìˆ˜ (1~100, ê¸°ë³¸: 20)
- `offset` (int): ì¡°íšŒ ì‹œì‘ ìœ„ì¹˜ (ê¸°ë³¸: 0)

**Response**:
```json
[
  {
    "id": 1,
    "user_id": 5,
    "post_id": 10,
    "campaign_id": 2,
    "notification_type": "due_date_reminder",
    "message_content": "ë§ˆê°ì¼ 2ì¼ ì „ ì•Œë¦¼: ì¸ìŠ¤íƒ€ê·¸ë¨ í”¼ë“œ í¬ìŠ¤íŒ…",
    "is_sent": true,
    "sent_at": "2025-10-28T09:00:00",
    "error_message": null,
    "created_at": "2025-10-28T09:00:00"
  }
]
```

---

### 3. ê´€ë¦¬ì ì „ìš©

#### `GET /stats`
í…”ë ˆê·¸ë¨ ì•Œë¦¼ í†µê³„ (SUPER_ADMIN, AGENCY_ADMINë§Œ)

**Response**:
```json
{
  "total_users_with_telegram": 50,
  "active_notifications": 45,
  "notifications_sent_today": 120,
  "notifications_failed_today": 5,
  "upcoming_deadlines": 30
}
```

#### `GET /admin/all-settings?page=1&size=20&is_enabled=true`
ëª¨ë“  ì‚¬ìš©ìì˜ í…”ë ˆê·¸ë¨ ì„¤ì • ì¡°íšŒ (ê´€ë¦¬ììš©)

**Query Parameters**:
- `page` (int): í˜ì´ì§€ ë²ˆí˜¸ (ê¸°ë³¸: 1)
- `size` (int): í˜ì´ì§€ë‹¹ í•­ëª© ìˆ˜ (1~100, ê¸°ë³¸: 20)
- `is_enabled` (bool, optional): í™œì„±í™” ì—¬ë¶€ í•„í„°

**Response**:
```json
{
  "total": 50,
  "page": 1,
  "size": 20,
  "settings": [...]
}
```

#### `POST /test-deadline-notifications?force_all=false`
í…”ë ˆê·¸ë¨ ë§ˆê°ì¼ ì•Œë¦¼ í…ŒìŠ¤íŠ¸ (ê´€ë¦¬ììš©)

**Query Parameters**:
- `force_all` (bool): ëª¨ë“  ì•Œë¦¼ ì‹œê°„ëŒ€ì—ì„œ ê°•ì œ ì‹¤í–‰ (ê¸°ë³¸: false)

**Response**:
```json
{
  "success": true,
  "message": "í…”ë ˆê·¸ë¨ ë§ˆê°ì¼ ì•Œë¦¼ í…ŒìŠ¤íŠ¸ê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.",
  "force_all": false,
  "executed_at": "2025-10-28T10:30:00"
}
```

---

## ìŠ¤ì¼€ì¤„ëŸ¬ ë™ì‘ ë°©ì‹

### ì‹¤í–‰ ì£¼ê¸°
- **15ë¶„ë§ˆë‹¤** ìë™ìœ¼ë¡œ ë§ˆê°ì¼ ì²´í¬ (`check_interval = 900`)
- ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹œì‘ ì‹œ ë°±ê·¸ë¼ìš´ë“œë¡œ ìë™ ì‹¤í–‰

### ì•Œë¦¼ ì¡°ê±´

#### 1. ì‚¬ìš©ì í•„í„°ë§
```python
# í´ë¼ì´ì–¸íŠ¸ ì—­í•  ì œì™¸ + í™œì„±í™”ëœ í…”ë ˆê·¸ë¨ ì„¤ì • + í™œì„± ì‚¬ìš©ìë§Œ
telegram_users = db.query(UserTelegramSetting).join(User).filter(
    and_(
        User.role != UserRole.CLIENT,
        UserTelegramSetting.is_enabled == True,
        User.is_active == True
    )
).all()
```

#### 2. ë§ˆê°ì¼ ì²´í¬ ë¡œì§
```python
# date_utils.should_send_telegram_notification() í•¨ìˆ˜ ì‚¬ìš©
should_send, days_left = should_send_telegram_notification(
    due_datetime=due_datetime,
    days_before_setting=days_before,  # ì‚¬ìš©ì ì„¤ì •ê°’
    current_time=now,
    grace_period_hours=12.0  # ë§ˆê° í›„ 12ì‹œê°„ê¹Œì§€ ìœ ì˜ˆ
)

# ì•Œë¦¼ ì¡°ê±´:
# 1. ë§ˆê° ì „: days_before_setting ì¼ ì´ë‚´
# 2. ë§ˆê° í›„: grace_period_hours ì‹œê°„ ì´ë‚´
# ì˜ˆ: days_before_setting=2, grace_period=12ì‹œê°„
#     â†’ ë§ˆê° 2ì¼ ì „ ~ ë§ˆê° í›„ 12ì‹œê°„ê¹Œì§€ ì•Œë¦¼
```

#### 3. ì¤‘ë³µ ë°œì†¡ ë°©ì§€
```python
# ì˜¤ëŠ˜ ì´ë¯¸ ì•Œë¦¼ì„ ë³´ë‚¸ ì ì´ ìˆëŠ”ì§€ í™•ì¸
existing_log = db.query(TelegramNotificationLog).filter(
    and_(
        TelegramNotificationLog.user_id == user.id,
        TelegramNotificationLog.post_id == post.id,
        TelegramNotificationLog.notification_type == "due_date_reminder",
        TelegramNotificationLog.is_sent == True,
        func.date(TelegramNotificationLog.created_at) == func.date(datetime.utcnow())
    )
).first()

if existing_log:
    continue  # ì´ë¯¸ ì „ì†¡ë¨, ìŠ¤í‚µ
```

#### 4. ì•Œë¦¼ ì‹œê°„ ì²´í¬
```python
# Â±2ì‹œê°„ ë²”ìœ„ ë‚´ì—ì„œ ì•Œë¦¼ ì‹œê°„ìœ¼ë¡œ íŒë‹¨
def is_notification_time(self, notification_time: str) -> bool:
    hour, minute = map(int, notification_time.split(':'))
    target_minutes = hour * 60 + minute
    current_minutes = datetime.now().hour * 60 + datetime.now().minute

    return abs(current_minutes - target_minutes) <= 120  # Â±2ì‹œê°„
```

### ì „ì²´ í”Œë¡œìš°

```
[15ë¶„ë§ˆë‹¤ ì‹¤í–‰]
     â”‚
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. CLIENT ì œì™¸í•œ í™œì„± ì‚¬ìš©ì ì¡°íšŒ     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 2. ê° ì‚¬ìš©ìë³„ë¡œ:                     â”‚
â”‚    - ìƒì„±í•œ ìº í˜ì¸ì˜ posts ì¡°íšŒ       â”‚
â”‚    - due_date ìˆëŠ” ê²ƒë§Œ í•„í„°ë§        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 3. ê° postë³„ë¡œ:                       â”‚
â”‚    â”œâ”€ due_date íŒŒì‹± (date_utils)     â”‚
â”‚    â”œâ”€ ì•Œë¦¼ ì¡°ê±´ ì²´í¬:                â”‚
â”‚    â”‚  â”œâ”€ ì˜¤ëŠ˜ ì´ë¯¸ ì „ì†¡í–ˆëŠ”ì§€         â”‚
â”‚    â”‚  â”œâ”€ ì•Œë¦¼ ì‹œê°„ëŒ€ì¸ì§€ (Â±2ì‹œê°„)    â”‚
â”‚    â”‚  â””â”€ ë§ˆê°ì¼ ë²”ìœ„ ë‚´ì¸ì§€           â”‚
â”‚    â””â”€ ì¡°ê±´ ë§Œì¡± ì‹œ ì „ì†¡              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 4. í…”ë ˆê·¸ë¨ ë©”ì‹œì§€ ì „ì†¡              â”‚
â”‚    - telegram_service.send_...()     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 5. ë¡œê·¸ ì €ì¥                         â”‚
â”‚    - TelegramNotificationLog ìƒì„±    â”‚
â”‚    - is_sent, error_message ê¸°ë¡     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 6. last_notification_at ì—…ë°ì´íŠ¸     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ë‚ ì§œ ì²˜ë¦¬ ë¡œì§

**íŒŒì¼**: `app/utils/date_utils.py`

### 1. `parse_due_datetime(due_date_str, default_time, user_timezone)`

**ëª©ì **: due_date ë¬¸ìì—´ì„ ì •í™•í•œ datetimeìœ¼ë¡œ ë³€í™˜

**ì§€ì› í˜•ì‹**:
1. `"2025-09-25"` â†’ `datetime(2025, 9, 25, 18, 0)` (ê¸°ë³¸ 18:00)
2. `"2025-09-25 15:30"` â†’ `datetime(2025, 9, 25, 15, 30)`
3. `"2025-09-25 15:30:00"` â†’ `datetime(2025, 9, 25, 15, 30, 0)`
4. `"2025-09-25T15:30:00"` (ISO) â†’ `datetime(2025, 9, 25, 15, 30, 0)`
5. `"2025-09-25T15:30:00Z"` (ISO + Z) â†’ `datetime(2025, 9, 25, 15, 30, 0)`

**Parameters**:
- `due_date_str` (str): íŒŒì‹±í•  ë‚ ì§œ ë¬¸ìì—´
- `default_time` (str): ì‹œê°„ì´ ì—†ì„ ë•Œ ê¸°ë³¸ ì‹œê°„ (ê¸°ë³¸: "18:00")
- `user_timezone` (str, optional): ì‚¬ìš©ì ì‹œê°„ëŒ€ (í–¥í›„ í™•ì¥ìš©)

**Returns**: `datetime` ê°ì²´ ë˜ëŠ” `None` (íŒŒì‹± ì‹¤íŒ¨ ì‹œ)

---

### 2. `should_send_telegram_notification(due_datetime, days_before_setting, current_time, grace_period_hours)`

**ëª©ì **: í…”ë ˆê·¸ë¨ ì•Œë¦¼ì„ ë³´ë‚´ì•¼ í•˜ëŠ”ì§€ íŒë‹¨

**ì•Œë¦¼ ì¡°ê±´**:
1. **ë§ˆê° ì „**: `days_before_setting` ì¼ ì´ë‚´
2. **ë§ˆê° í›„**: `grace_period_hours` ì‹œê°„ ì´ë‚´ (ìœ ì˜ˆ ê¸°ê°„)

**ì˜ˆì‹œ**:
```python
# ì‚¬ìš©ì ì„¤ì •: 2ì¼ ì „ ì•Œë¦¼, ìœ ì˜ˆ 12ì‹œê°„
days_before_setting = 2
grace_period_hours = 12.0

# ë§ˆê°ì¼: 2025-11-15 18:00
# í˜„ì¬: 2025-11-13 10:00 â†’ days_left = 2.33ì¼ â†’ âœ… ì•Œë¦¼ (2ì¼ ì´ë‚´)
# í˜„ì¬: 2025-11-15 20:00 â†’ days_left = -0.08ì¼ â†’ âœ… ì•Œë¦¼ (ë§ˆê° í›„ 2ì‹œê°„, ìœ ì˜ˆ 12ì‹œê°„ ì´ë‚´)
# í˜„ì¬: 2025-11-16 10:00 â†’ days_left = -0.67ì¼ â†’ âŒ ì•Œë¦¼ ì•ˆ í•¨ (ë§ˆê° í›„ 16ì‹œê°„, ìœ ì˜ˆ ì´ˆê³¼)
```

**Parameters**:
- `due_datetime` (datetime): ë§ˆê° ì¼ì‹œ
- `days_before_setting` (int): ì‚¬ìš©ì ì„¤ì • (ë©°ì¹  ì „ ì•Œë¦¼)
- `current_time` (datetime, optional): í˜„ì¬ ì‹œê°„
- `grace_period_hours` (float): ë§ˆê° í›„ ì•Œë¦¼ ìœ ì˜ˆì‹œê°„ (ê¸°ë³¸: 12.0)

**Returns**: `(should_send: bool, days_left: float)`

---

### 3. `format_due_datetime_for_display(dt)`

**ëª©ì **: datetimeì„ ì‚¬ìš©ì ì¹œí™”ì  í˜•ì‹ìœ¼ë¡œ í¬ë§·íŒ…

**ì˜ˆì‹œ**:
```python
dt = datetime(2025, 11, 15, 18, 0)
result = format_due_datetime_for_display(dt)
# result: "2025-11-15 18:00"
```

---

## ì „ì²´ ì½”ë“œ

### 1. TelegramService ì „ì²´ ì½”ë“œ

**íŒŒì¼**: `app/services/telegram_service.py`

```python
import asyncio
import httpx
import logging
from typing import Optional, Dict, Any
from datetime import datetime, timezone
import os

logger = logging.getLogger(__name__)


class TelegramService:
    """í…”ë ˆê·¸ë¨ ë´‡ API ì„œë¹„ìŠ¤"""

    def __init__(self, bot_token: Optional[str] = None):
        self.bot_token = bot_token or os.getenv("TELEGRAM_BOT_TOKEN")
        self.base_url = f"https://api.telegram.org/bot{self.bot_token}" if self.bot_token else None
        self.timeout = 30.0

    async def send_message(
        self,
        chat_id: str,
        message: str,
        parse_mode: str = "HTML",
        disable_web_page_preview: bool = True
    ) -> Dict[str, Any]:
        """í…”ë ˆê·¸ë¨ ë©”ì‹œì§€ ì „ì†¡"""

        if not self.bot_token:
            raise ValueError("TELEGRAM_BOT_TOKEN í™˜ê²½ë³€ìˆ˜ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")

        url = f"{self.base_url}/sendMessage"

        payload = {
            "chat_id": chat_id,
            "text": message,
            "parse_mode": parse_mode,
            "disable_web_page_preview": disable_web_page_preview
        }

        try:
            async with httpx.AsyncClient(timeout=self.timeout) as client:
                response = await client.post(url, json=payload)

                if response.status_code == 200:
                    result = response.json()
                    if result.get("ok"):
                        logger.info(f"í…”ë ˆê·¸ë¨ ë©”ì‹œì§€ ì „ì†¡ ì„±ê³µ: chat_id={chat_id}")
                        return {
                            "success": True,
                            "message_id": result.get("result", {}).get("message_id"),
                            "data": result
                        }
                    else:
                        error_msg = result.get("description", "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜")
                        logger.error(f"í…”ë ˆê·¸ë¨ API ì˜¤ë¥˜: {error_msg}")
                        return {
                            "success": False,
                            "error": error_msg,
                            "error_code": result.get("error_code")
                        }
                else:
                    logger.error(f"í…”ë ˆê·¸ë¨ API HTTP ì˜¤ë¥˜: {response.status_code}")
                    return {
                        "success": False,
                        "error": f"HTTP {response.status_code}: {response.text}",
                        "error_code": response.status_code
                    }

        except httpx.TimeoutException:
            logger.error("í…”ë ˆê·¸ë¨ API íƒ€ì„ì•„ì›ƒ")
            return {
                "success": False,
                "error": "ìš”ì²­ íƒ€ì„ì•„ì›ƒ",
                "error_code": "TIMEOUT"
            }
        except Exception as e:
            logger.error(f"í…”ë ˆê·¸ë¨ ë©”ì‹œì§€ ì „ì†¡ ì‹¤íŒ¨: {str(e)}")
            return {
                "success": False,
                "error": str(e),
                "error_code": "UNKNOWN"
            }

    async def get_chat_info(self, chat_id: str) -> Dict[str, Any]:
        """ì±„íŒ… ì •ë³´ ì¡°íšŒ (chat_id ìœ íš¨ì„± ê²€ì¦ìš©)"""

        if not self.bot_token:
            raise ValueError("TELEGRAM_BOT_TOKEN í™˜ê²½ë³€ìˆ˜ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")

        url = f"{self.base_url}/getChat"
        payload = {"chat_id": chat_id}

        try:
            async with httpx.AsyncClient(timeout=self.timeout) as client:
                response = await client.post(url, json=payload)

                if response.status_code == 200:
                    result = response.json()
                    if result.get("ok"):
                        return {
                            "success": True,
                            "data": result.get("result", {})
                        }
                    else:
                        return {
                            "success": False,
                            "error": result.get("description", "ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜")
                        }
                else:
                    return {
                        "success": False,
                        "error": f"HTTP {response.status_code}"
                    }

        except Exception as e:
            logger.error(f"í…”ë ˆê·¸ë¨ ì±„íŒ… ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨: {str(e)}")
            return {
                "success": False,
                "error": str(e)
            }

    async def send_campaign_deadline_reminder(
        self,
        chat_id: str,
        user_name: str,
        post_title: str,
        due_date: str,
        days_before: int,
        work_type: str = None,
        product_name: str = None
    ) -> Dict[str, Any]:
        """ìº í˜ì¸ ë§ˆê°ì¼ ì•Œë¦¼ ë©”ì‹œì§€ ì „ì†¡"""

        # ë§ˆê°ì¼ì´ ì„ë°•í•œ ì •ë„ì— ë”°ë¥¸ ì´ëª¨ì§€ ì„ íƒ
        if days_before <= 1:
            urgency_emoji = "ğŸš¨"
            urgency_text = "ê¸´ê¸‰"
        elif days_before <= 2:
            urgency_emoji = "âš ï¸"
            urgency_text = "ì¤‘ìš”"
        else:
            urgency_emoji = "ğŸ“…"
            urgency_text = "ì•Œë¦¼"

        # ë©”ì‹œì§€ ê¸°ë³¸ êµ¬ì¡°
        message_parts = [
            f"{urgency_emoji} <b>{urgency_text} - ìº í˜ì¸ ë§ˆê°ì¼ ì•Œë¦¼</b>",
            "",
            f"ì•ˆë…•í•˜ì„¸ìš”, <b>{user_name}</b>ë‹˜!",
            "",
            f"ğŸ“ <b>ì‘ì—…ëª…:</b> {post_title}"
        ]

        # work_typeì´ ìˆìœ¼ë©´ ì¶”ê°€
        if work_type:
            message_parts.append(f"ğŸ“‹ <b>ìƒí’ˆì¢…ë¥˜:</b> {work_type}")

        # product_nameì´ ìˆìœ¼ë©´ ì¶”ê°€
        if product_name:
            message_parts.append(f"ğŸ”— <b>ìƒí’ˆëª…:</b> {product_name}")

        # ë§ˆê°ì¼ê³¼ ë‚¨ì€ ì‹œê°„
        message_parts.extend([
            f"ğŸ“… <b>ë§ˆê°ì¼:</b> {due_date}",
            f"â° <b>ë‚¨ì€ ì‹œê°„:</b> <b>{days_before}ì¼</b>",
            "",
            "ë§ˆê°ì¼ì´ ë‹¤ê°€ì˜¤ê³  ìˆìŠµë‹ˆë‹¤. ì‘ì—… ì§„í–‰ ìƒí™©ì„ í™•ì¸í•´ ì£¼ì„¸ìš”!",
            "",
            "<i>BrandFlow ì•Œë¦¼ ì‹œìŠ¤í…œ</i>"
        ])

        message = "\n".join(message_parts)

        return await self.send_message(chat_id, message)

    async def send_test_message(self, chat_id: str, user_name: str) -> Dict[str, Any]:
        """í…ŒìŠ¤íŠ¸ ë©”ì‹œì§€ ì „ì†¡"""

        message = f"""
ğŸ¤– <b>í…”ë ˆê·¸ë¨ ì•Œë¦¼ í…ŒìŠ¤íŠ¸</b>

ì•ˆë…•í•˜ì„¸ìš”, <b>{user_name}</b>ë‹˜!

âœ… í…”ë ˆê·¸ë¨ ì•Œë¦¼ì´ ì •ìƒì ìœ¼ë¡œ ì„¤ì •ë˜ì—ˆìŠµë‹ˆë‹¤.
ğŸ“± ì´ì œ ìº í˜ì¸ ë§ˆê°ì¼ ì•Œë¦¼ì„ ë°›ìœ¼ì‹¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

<b>ì•Œë¦¼ ì„¤ì •:</b>
â€¢ ë§ˆê°ì¼ 2ì¼ ì „ ì•Œë¦¼
â€¢ ë§¤ì¼ ì˜¤ì „ 9ì‹œ ë°œì†¡

ì„¤ì •ì„ ë³€ê²½í•˜ì‹œë ¤ë©´ ì‹œìŠ¤í…œ ì„¤ì •ì—ì„œ ìˆ˜ì •í•´ ì£¼ì„¸ìš”.

<i>BrandFlow ì•Œë¦¼ ì‹œìŠ¤í…œ</i>
        """.strip()

        return await self.send_message(chat_id, message)


# ì „ì—­ í…”ë ˆê·¸ë¨ ì„œë¹„ìŠ¤ ì¸ìŠ¤í„´ìŠ¤
telegram_service = TelegramService()


async def send_telegram_message(chat_id: str, message: str) -> Dict[str, Any]:
    """ê°„í¸í•œ í…”ë ˆê·¸ë¨ ë©”ì‹œì§€ ì „ì†¡ í•¨ìˆ˜"""
    return await telegram_service.send_message(chat_id, message)


async def validate_telegram_chat_id(chat_id: str) -> bool:
    """í…”ë ˆê·¸ë¨ ì±„íŒ… ID ìœ íš¨ì„± ê²€ì¦"""
    try:
        result = await telegram_service.get_chat_info(chat_id)
        return result.get("success", False)
    except Exception:
        return False
```

---

### 2. TelegramScheduler ì „ì²´ ì½”ë“œ

**íŒŒì¼**: `app/services/telegram_scheduler.py`

```python
import asyncio
import logging
from datetime import datetime, timedelta, time
from typing import List, Tuple
from sqlalchemy.orm import Session, sessionmaker
from sqlalchemy import and_, func, or_

from app.db.database import sync_engine
from app.models.user import User, UserRole
from app.models.post import Post
from app.models.campaign import Campaign
from app.models.user_telegram_setting import UserTelegramSetting, TelegramNotificationLog
from app.services.telegram_service import telegram_service
from app.utils.date_utils import parse_due_datetime, should_send_telegram_notification, format_due_datetime_for_display

logger = logging.getLogger(__name__)

# ë°ì´í„°ë² ì´ìŠ¤ ì„¸ì…˜ íŒ©í† ë¦¬
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=sync_engine)


class TelegramScheduler:
    """í…”ë ˆê·¸ë¨ ì•Œë¦¼ ìŠ¤ì¼€ì¤„ëŸ¬"""

    def __init__(self):
        self.running = False
        self.check_interval = 900  # 15ë¶„ë§ˆë‹¤ ì²´í¬

    async def start(self):
        """ìŠ¤ì¼€ì¤„ëŸ¬ ì‹œì‘"""
        if self.running:
            logger.warning("í…”ë ˆê·¸ë¨ ìŠ¤ì¼€ì¤„ëŸ¬ê°€ ì´ë¯¸ ì‹¤í–‰ ì¤‘ì…ë‹ˆë‹¤")
            return

        self.running = True
        logger.info("í…”ë ˆê·¸ë¨ ì•Œë¦¼ ìŠ¤ì¼€ì¤„ëŸ¬ ì‹œì‘")

        while self.running:
            try:
                await self.check_and_send_notifications()
                await asyncio.sleep(self.check_interval)
            except Exception as e:
                logger.error(f"ìŠ¤ì¼€ì¤„ëŸ¬ ì˜¤ë¥˜: {str(e)}")
                await asyncio.sleep(60)  # ì˜¤ë¥˜ ì‹œ 1ë¶„ í›„ ì¬ì‹œë„

    def stop(self):
        """ìŠ¤ì¼€ì¤„ëŸ¬ ì¤‘ì§€"""
        self.running = False
        logger.info("í…”ë ˆê·¸ë¨ ì•Œë¦¼ ìŠ¤ì¼€ì¤„ëŸ¬ ì¤‘ì§€")

    async def check_and_send_notifications(self):
        """ë§ˆê°ì¼ ì„ë°• ì•Œë¦¼ í™•ì¸ ë° ì „ì†¡"""
        db = SessionLocal()

        try:
            logger.info(f"[TELEGRAM] ë§ˆê°ì¼ ì„ë°• ì•Œë¦¼ í™•ì¸ ì‹œì‘ - {datetime.utcnow()}")

            # í´ë¼ì´ì–¸íŠ¸ ì—­í• ì„ ì œì™¸í•œ ëª¨ë“  ì‚¬ìš©ìë“¤ì˜ í™œì„±í™”ëœ í…”ë ˆê·¸ë¨ ì„¤ì • ì¡°íšŒ
            telegram_users = db.query(UserTelegramSetting).join(User).filter(
                and_(
                    User.role != UserRole.CLIENT,
                    UserTelegramSetting.is_enabled == True,
                    User.is_active == True
                )
            ).all()

            if not telegram_users:
                logger.info("[TELEGRAM] ì•Œë¦¼ì„ ë°›ì„ ì‚¬ìš©ìê°€ ì—†ìŠµë‹ˆë‹¤")
                return

            logger.info(f"[TELEGRAM] ì•Œë¦¼ ëŒ€ìƒ ì‚¬ìš©ì ìˆ˜: {len(telegram_users)}")

            notifications_sent = 0

            for telegram_setting in telegram_users:
                user = telegram_setting.user

                # í•´ë‹¹ ì‚¬ìš©ìê°€ ë‹´ë‹¹í•˜ëŠ” posts ì¡°íšŒ
                user_posts = await self.get_user_posts_with_upcoming_deadlines(
                    db, user.id, telegram_setting.days_before_due
                )

                for post_info in user_posts:
                    post, campaign, days_left = post_info

                    # ì´ë¯¸ ì•Œë¦¼ì„ ë³´ë‚¸ ì ì´ ìˆëŠ”ì§€ í™•ì¸
                    existing_log = db.query(TelegramNotificationLog).filter(
                        and_(
                            TelegramNotificationLog.user_id == user.id,
                            TelegramNotificationLog.post_id == post.id,
                            TelegramNotificationLog.notification_type == "due_date_reminder",
                            TelegramNotificationLog.is_sent == True,
                            func.date(TelegramNotificationLog.created_at) == func.date(datetime.utcnow())
                        )
                    ).first()

                    if existing_log:
                        logger.debug(f"ì´ë¯¸ ì•Œë¦¼ ì „ì†¡ë¨: user_id={user.id}, post_id={post.id}")
                        continue

                    # ì•Œë¦¼ ì‹œê°„ í™•ì¸
                    current_time = datetime.now().strftime("%H:%M")
                    if not self.is_notification_time(telegram_setting.notification_time):
                        logger.debug(f"[TELEGRAM] ì•Œë¦¼ ì‹œê°„ì´ ì•„ë‹˜ - ì„¤ì •: {telegram_setting.notification_time}, í˜„ì¬: {current_time}")
                        continue

                    logger.info(f"[TELEGRAM] ì•Œë¦¼ ì‹œê°„ ì¡°ê±´ ë§Œì¡± - ì‚¬ìš©ì: {user.name}")

                    # í…”ë ˆê·¸ë¨ ì•Œë¦¼ ì „ì†¡
                    await self.send_deadline_notification(
                        db, user, post, campaign, days_left, telegram_setting
                    )
                    notifications_sent += 1

            logger.info(f"[TELEGRAM] ë§ˆê°ì¼ ì„ë°• ì•Œë¦¼ {notifications_sent}ê°œ ì „ì†¡ ì™„ë£Œ")

        except Exception as e:
            logger.error(f"ì•Œë¦¼ í™•ì¸ ì¤‘ ì˜¤ë¥˜: {str(e)}")
        finally:
            db.close()

    async def get_user_posts_with_upcoming_deadlines(
        self, db: Session, user_id: int, days_before: int
    ) -> List[Tuple[Post, Campaign, float]]:
        """ì‚¬ìš©ìì˜ ë§ˆê°ì¼ ì„ë°• posts ì¡°íšŒ"""

        try:
            now = datetime.now()
            logger.info(f"[TELEGRAM] ë§ˆê°ì¼ ì²´í¬ ê¸°ì¤€ ì‹œê°„: {now}")

            # ì‚¬ìš©ìê°€ ìƒì„±í•œ ìº í˜ì¸ì˜ posts ì¡°íšŒ
            posts_with_deadlines = db.query(Post, Campaign).join(Campaign).filter(
                and_(
                    Campaign.creator_id == user_id,
                    Post.due_date.isnot(None),
                    Post.due_date != '',
                    Post.is_active == True
                )
            ).all()

            logger.info(f"[TELEGRAM] ì‚¬ìš©ì {user_id}ì˜ ë§ˆê°ì¼ ìˆëŠ” posts: {len(posts_with_deadlines)}ê°œ")

            upcoming_posts = []

            for post, campaign in posts_with_deadlines:
                try:
                    due_datetime = parse_due_datetime(post.due_date, default_time="18:00")

                    if not due_datetime:
                        logger.warning(f"[TELEGRAM] ë‚ ì§œ íŒŒì‹± ì‹¤íŒ¨: post_id={post.id}")
                        continue

                    should_send, days_left = should_send_telegram_notification(
                        due_datetime=due_datetime,
                        days_before_setting=days_before,
                        current_time=now,
                        grace_period_hours=12.0
                    )

                    if should_send:
                        upcoming_posts.append((post, campaign, days_left))
                        logger.info(f"[TELEGRAM] ì•Œë¦¼ ëŒ€ìƒ: Post {post.id} - {days_left:.1f}ì¼ í›„ ë§ˆê°")

                except Exception as e:
                    logger.error(f"[TELEGRAM] Post {post.id} ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜: {str(e)}")
                    continue

            return upcoming_posts

        except Exception as e:
            logger.error(f"ë§ˆê°ì¼ ì„ë°• posts ì¡°íšŒ ì˜¤ë¥˜: {str(e)}")
            return []

    async def send_deadline_notification(
        self,
        db: Session,
        user: User,
        post: Post,
        campaign: Campaign,
        days_left: float,
        telegram_setting: UserTelegramSetting
    ):
        """ë§ˆê°ì¼ ì•Œë¦¼ ì „ì†¡"""

        try:
            due_datetime = parse_due_datetime(post.due_date, default_time="18:00")
            due_info = format_due_datetime_for_display(due_datetime) if due_datetime else f"{post.due_date} 18:00"

            result = await telegram_service.send_campaign_deadline_reminder(
                chat_id=telegram_setting.telegram_chat_id,
                user_name=user.name,
                post_title=post.title,
                due_date=due_info,
                days_before=telegram_setting.days_before_due,
                work_type=post.work_type,
                product_name=post.product_name
            )

            # ë¡œê·¸ ì €ì¥
            log = TelegramNotificationLog(
                user_id=user.id,
                post_id=post.id,
                campaign_id=campaign.id,
                notification_type="due_date_reminder",
                message_content=f"ë§ˆê°ì¼ {telegram_setting.days_before_due}ì¼ ì „ ì•Œë¦¼: {post.title}",
                telegram_chat_id=telegram_setting.telegram_chat_id,
                is_sent=result.get("success", False),
                sent_at=datetime.utcnow() if result.get("success") else None,
                error_message=result.get("error") if not result.get("success") else None,
                telegram_message_id=str(result.get("message_id", "")) if result.get("success") else None
            )

            db.add(log)
            db.commit()

            if result.get("success"):
                logger.info(f"ë§ˆê°ì¼ ì•Œë¦¼ ì „ì†¡ ì„±ê³µ: user={user.name}, post={post.title}")
                telegram_setting.last_notification_at = datetime.utcnow()
                db.commit()
            else:
                logger.error(f"ë§ˆê°ì¼ ì•Œë¦¼ ì „ì†¡ ì‹¤íŒ¨: user={user.name}, error={result.get('error')}")

        except Exception as e:
            logger.error(f"ë§ˆê°ì¼ ì•Œë¦¼ ì „ì†¡ ì¤‘ ì˜¤ë¥˜: {str(e)}")

    def is_notification_time(self, notification_time: str) -> bool:
        """í˜„ì¬ ì‹œê°„ì´ ì•Œë¦¼ ì‹œê°„ì¸ì§€ í™•ì¸ (Â±2ì‹œê°„)"""
        try:
            hour, minute = map(int, notification_time.split(':'))
            target_minutes = hour * 60 + minute
            current_minutes = datetime.now().hour * 60 + datetime.now().minute

            return abs(current_minutes - target_minutes) <= 120

        except Exception as e:
            logger.error(f"ì•Œë¦¼ ì‹œê°„ í™•ì¸ ì˜¤ë¥˜: {str(e)}")
            return False


# ì „ì—­ ìŠ¤ì¼€ì¤„ëŸ¬ ì¸ìŠ¤í„´ìŠ¤
telegram_scheduler = TelegramScheduler()


async def start_telegram_scheduler():
    """í…”ë ˆê·¸ë¨ ìŠ¤ì¼€ì¤„ëŸ¬ ì‹œì‘"""
    await telegram_scheduler.start()


def stop_telegram_scheduler():
    """í…”ë ˆê·¸ë¨ ìŠ¤ì¼€ì¤„ëŸ¬ ì¤‘ì§€"""
    telegram_scheduler.stop()
```

---

## í™˜ê²½ ë³€ìˆ˜ ì„¤ì •

**í•„ìˆ˜ í™˜ê²½ ë³€ìˆ˜**:
```bash
TELEGRAM_BOT_TOKEN=your_bot_token_here
```

**ì„¤ì • ë°©ë²•**:
1. Railway Dashboard â†’ Environment Variables
2. `.env` íŒŒì¼ì— ì¶”ê°€ (ë¡œì»¬ ê°œë°œìš©)

---

## í…”ë ˆê·¸ë¨ ë´‡ ì„¤ì • ë°©ë²•

### 1. BotFatherë¡œ ë´‡ ìƒì„±
1. í…”ë ˆê·¸ë¨ì—ì„œ `@BotFather` ê²€ìƒ‰
2. `/newbot` ëª…ë ¹ì–´ ì…ë ¥
3. ë´‡ ì´ë¦„ ì…ë ¥ (ì˜ˆ: BrandFlow Notification Bot)
4. ë´‡ ì‚¬ìš©ìëª… ì…ë ¥ (ì˜ˆ: brandflow_notification_bot)
5. **Bot Token ë³µì‚¬** â†’ í™˜ê²½ ë³€ìˆ˜ì— ì„¤ì •

### 2. Chat ID í™•ì¸
1. ìƒì„±í•œ ë´‡ê³¼ ëŒ€í™” ì‹œì‘ (`/start`)
2. ë©”ì‹œì§€ ì „ì†¡ (ì•„ë¬´ ë©”ì‹œì§€ë‚˜)
3. ë¸Œë¼ìš°ì €ì—ì„œ ì ‘ì†:
   ```
   https://api.telegram.org/bot<YOUR_BOT_TOKEN>/getUpdates
   ```
4. JSONì—ì„œ `chat.id` ê°’ í™•ì¸ (ì˜ˆ: `123456789`)

### 3. ì‹œìŠ¤í…œì— ì„¤ì • ë“±ë¡
- API: `POST /api/telegram-settings/my-setting`
- Body:
  ```json
  {
    "telegram_chat_id": "123456789",
    "is_enabled": true,
    "days_before_due": 2,
    "notification_time": "09:00"
  }
  ```

---

## í…ŒìŠ¤íŠ¸ ë°©ë²•

### 1. í…ŒìŠ¤íŠ¸ ë©”ì‹œì§€ ë°œì†¡
```bash
POST /api/telegram-settings/test
{
  "message": "í…ŒìŠ¤íŠ¸ ë©”ì‹œì§€ì…ë‹ˆë‹¤."
}
```

### 2. ê´€ë¦¬ì í…ŒìŠ¤íŠ¸ (ë§ˆê°ì¼ ì•Œë¦¼ ê°•ì œ ì‹¤í–‰)
```bash
POST /api/telegram-settings/test-deadline-notifications?force_all=true
```

### 3. ë¡œê·¸ í™•ì¸
```bash
GET /api/telegram-settings/logs?limit=20
```

---

## íŠ¸ëŸ¬ë¸”ìŠˆíŒ…

### ë¬¸ì œ 1: ì•Œë¦¼ì´ ì „ì†¡ë˜ì§€ ì•ŠìŒ

**ì²´í¬ë¦¬ìŠ¤íŠ¸**:
1. `TELEGRAM_BOT_TOKEN` í™˜ê²½ ë³€ìˆ˜ ì„¤ì • í™•ì¸
2. `is_enabled = true` í™•ì¸
3. `User.is_active = true` í™•ì¸
4. í˜„ì¬ ì‹œê°„ì´ ì•Œë¦¼ ì‹œê°„ëŒ€ì¸ì§€ í™•ì¸ (Â±2ì‹œê°„)
5. ì˜¤ëŠ˜ ì´ë¯¸ ì•Œë¦¼ì„ ë³´ëƒˆëŠ”ì§€ í™•ì¸ (ì¤‘ë³µ ë°©ì§€)
6. ë§ˆê°ì¼ì´ `days_before_due` ë²”ìœ„ ë‚´ì¸ì§€ í™•ì¸

### ë¬¸ì œ 2: "Invalid chat_id" ì˜¤ë¥˜

**í•´ê²°**:
- Chat ID í™•ì¸ ë°©ë²•ëŒ€ë¡œ ì •í™•í•œ ID ì…ë ¥
- ë´‡ê³¼ ëŒ€í™”ë¥¼ ë¨¼ì € ì‹œì‘í•´ì•¼ í•¨ (`/start`)

### ë¬¸ì œ 3: ìŠ¤ì¼€ì¤„ëŸ¬ê°€ ì‹œì‘ë˜ì§€ ì•ŠìŒ

**í•´ê²°**:
- `app/main.py`ì— ìŠ¤ì¼€ì¤„ëŸ¬ ì‹œì‘ ì½”ë“œ í™•ì¸:
  ```python
  @app.on_event("startup")
  async def startup_event():
      asyncio.create_task(start_telegram_scheduler())
  ```

---

## í–¥í›„ ê°œì„  ì‚¬í•­

1. **ì‹œê°„ëŒ€ ì§€ì›**: ì‚¬ìš©ìë³„ íƒ€ì„ì¡´ ì„¤ì •
2. **ì•Œë¦¼ ë¹ˆë„ ì„¤ì •**: ë§¤ì¼/ì£¼ê°„/ì›”ê°„ ë“±
3. **ì•Œë¦¼ ìœ í˜• í™•ì¥**: ìº í˜ì¸ ìŠ¹ì¸, ê²°ì œ ì™„ë£Œ ë“±
4. **Webhook ì§€ì›**: Polling ëŒ€ì‹  Webhook ë°©ì‹
5. **ë©”ì‹œì§€ í…œí”Œë¦¿**: ì‚¬ìš©ì ì •ì˜ ë©”ì‹œì§€ í…œí”Œë¦¿
6. **ê·¸ë£¹ ì±„íŒ… ì§€ì›**: íŒ€ ë‹¨ìœ„ ì•Œë¦¼

---

**ë¬¸ì„œ ì‘ì„±ì¼**: 2025-10-30
**ë²„ì „**: 1.0
**ì‘ì„±ì**: Claude Code
