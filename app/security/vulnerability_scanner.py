"""
보안 취약점 스캔 시스템
- SQL 인젝션 감지
- XSS 공격 탐지
- 권한 상승 시도 감지  
- 의심스러운 API 패턴 분석
- 자동 보안 알림
"""

import re
import hashlib
import json
from datetime import datetime, timedelta
from typing import List, Dict, Optional
from collections import defaultdict, deque
import asyncio
from starlette.requests import Request
from sqlalchemy.ext.asyncio import AsyncSession

class SecurityThreat:
    """보안 위협 클래스"""
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    
    SQL_INJECTION = "sql_injection"
    XSS = "xss"
    AUTH_BYPASS = "auth_bypass"
    PRIVILEGE_ESCALATION = "privilege_escalation"
    BRUTE_FORCE = "brute_force"
    SUSPICIOUS_PATTERN = "suspicious_pattern"

class VulnerabilityScanner:
    def __init__(self):
        self.threat_patterns = {
            SecurityThreat.SQL_INJECTION: [
                r"(\s|^)(union\s+select|select.*from|insert\s+into|update.*set|delete\s+from)",
                r"(\s|^)(drop\s+table|create\s+table|alter\s+table)",
                r"(\s|^)(exec|execute|sp_|xp_)",
                r"['\"];?\s*(--)|(#)|(\*)|(/\*)",
                r"\bOR\b.*=.*\bOR\b",
                r"(1=1|1=2|true=true)"
            ],
            SecurityThreat.XSS: [
                r"<script[^>]*>.*?</script>",
                r"javascript:\s*[^;]*",
                r"on\w+\s*=\s*['\"][^'\"]*['\"]",
                r"<iframe[^>]*>.*?</iframe>",
                r"<object[^>]*>.*?</object>",
                r"eval\s*\([^)]*\)",
                r"document\.(cookie|write|location)"
            ],
            SecurityThreat.AUTH_BYPASS: [
                r"admin['\"]?\s*:\s*['\"]?admin",
                r"password['\"]?\s*:\s*['\"]?(password|123456|admin)",
                r"(bypass|skip).*auth",
                r"token.*=.*null"
            ]
        }
        
        self.failed_attempts = defaultdict(deque)  # IP별 실패 시도
        self.suspicious_ips = set()
        self.security_alerts = deque(maxlen=1000)  # 최근 1000개 알림
        
    def scan_request(self, request: Request, body: str = None) -> List[Dict]:
        """요청 전체 보안 스캔"""
        threats = []
        
        # URL 파라미터 스캔
        url_threats = self._scan_parameters(dict(request.query_params))
        if url_threats:
            threats.extend(url_threats)
        
        # Request Body 스캔
        if body:
            try:
                body_data = json.loads(body) if body.startswith('{') else {'body': body}
                body_threats = self._scan_parameters(body_data)
                if body_threats:
                    threats.extend(body_threats)
            except:
                # JSON이 아닌 경우 텍스트로 스캔
                text_threats = self._scan_text(body)
                if text_threats:
                    threats.extend(text_threats)
        
        # 헤더 스캔
        header_threats = self._scan_headers(dict(request.headers))
        if header_threats:
            threats.extend(header_threats)
        
        # IP 평판 확인
        client_ip = request.client.host
        ip_threats = self._check_ip_reputation(client_ip)
        if ip_threats:
            threats.extend(ip_threats)
        
        return threats
    
    def _scan_parameters(self, params: Dict) -> List[Dict]:
        """파라미터 스캔"""
        threats = []
        
        for key, value in params.items():
            if isinstance(value, (list, dict)):
                continue
                
            value_str = str(value).lower()
            
            # SQL 인젝션 패턴 검사
            for pattern in self.threat_patterns[SecurityThreat.SQL_INJECTION]:
                if re.search(pattern, value_str, re.IGNORECASE):
                    threats.append({
                        'type': SecurityThreat.SQL_INJECTION,
                        'severity': SecurityThreat.HIGH,
                        'parameter': key,
                        'value': str(value)[:100],  # 처음 100자만
                        'pattern': pattern,
                        'timestamp': datetime.now().isoformat()
                    })
            
            # XSS 패턴 검사
            for pattern in self.threat_patterns[SecurityThreat.XSS]:
                if re.search(pattern, value_str, re.IGNORECASE):
                    threats.append({
                        'type': SecurityThreat.XSS,
                        'severity': SecurityThreat.HIGH,
                        'parameter': key,
                        'value': str(value)[:100],
                        'pattern': pattern,
                        'timestamp': datetime.now().isoformat()
                    })
            
            # 인증 우회 패턴 검사
            for pattern in self.threat_patterns[SecurityThreat.AUTH_BYPASS]:
                if re.search(pattern, value_str, re.IGNORECASE):
                    threats.append({
                        'type': SecurityThreat.AUTH_BYPASS,
                        'severity': SecurityThreat.HIGH,
                        'parameter': key,
                        'value': str(value)[:100],
                        'pattern': pattern,
                        'timestamp': datetime.now().isoformat()
                    })
        
        return threats
    
    def _scan_text(self, text: str) -> List[Dict]:
        """일반 텍스트 스캔"""
        threats = []
        text_lower = text.lower()
        
        for threat_type, patterns in self.threat_patterns.items():
            for pattern in patterns:
                matches = re.finditer(pattern, text_lower, re.IGNORECASE)
                for match in matches:
                    threats.append({
                        'type': threat_type,
                        'severity': SecurityThreat.HIGH,
                        'content': match.group()[:100],
                        'position': match.start(),
                        'pattern': pattern,
                        'timestamp': datetime.now().isoformat()
                    })
        
        return threats
    
    def _scan_headers(self, headers: Dict) -> List[Dict]:
        """HTTP 헤더 스캔"""
        threats = []
        
        # 위험한 User-Agent 패턴
        user_agent = headers.get('user-agent', '').lower()
        suspicious_agents = ['sqlmap', 'nikto', 'nmap', 'dirb', 'burp']
        
        for agent in suspicious_agents:
            if agent in user_agent:
                threats.append({
                    'type': SecurityThreat.SUSPICIOUS_PATTERN,
                    'severity': SecurityThreat.HIGH,
                    'header': 'user-agent',
                    'value': user_agent[:100],
                    'reason': f'Suspicious tool detected: {agent}',
                    'timestamp': datetime.now().isoformat()
                })
        
        # 비정상적인 헤더 조합
        if 'x-forwarded-for' in headers and 'x-real-ip' in headers:
            forwarded_ips = headers['x-forwarded-for'].split(',')
            if len(forwarded_ips) > 5:  # 과도한 프록시 체인
                threats.append({
                    'type': SecurityThreat.SUSPICIOUS_PATTERN,
                    'severity': SecurityThreat.MEDIUM,
                    'header': 'x-forwarded-for',
                    'value': headers['x-forwarded-for'][:100],
                    'reason': 'Excessive proxy chain detected',
                    'timestamp': datetime.now().isoformat()
                })
        
        return threats
    
    def _check_ip_reputation(self, ip: str) -> List[Dict]:
        """IP 평판 확인"""
        threats = []
        
        # 로컬 IP는 제외
        if ip.startswith(('127.', '10.', '192.168.', '172.')):
            return threats
        
        # 의심스러운 IP 목록에 있는지 확인
        if ip in self.suspicious_ips:
            threats.append({
                'type': SecurityThreat.SUSPICIOUS_PATTERN,
                'severity': SecurityThreat.HIGH,
                'ip': ip,
                'reason': 'IP in suspicious list',
                'timestamp': datetime.now().isoformat()
            })
        
        # 최근 실패 시도 확인 (브루트 포스)
        recent_failures = len([
            ts for ts in self.failed_attempts[ip] 
            if datetime.now() - ts < timedelta(minutes=10)
        ])
        
        if recent_failures > 20:  # 10분간 20회 이상 실패
            threats.append({
                'type': SecurityThreat.BRUTE_FORCE,
                'severity': SecurityThreat.HIGH,
                'ip': ip,
                'failure_count': recent_failures,
                'reason': 'Excessive failed attempts',
                'timestamp': datetime.now().isoformat()
            })
        
        return threats
    
    def record_failed_attempt(self, ip: str, endpoint: str):
        """인증 실패 시도 기록"""
        self.failed_attempts[ip].append(datetime.now())
        
        # 10분 이전 기록은 제거
        cutoff = datetime.now() - timedelta(minutes=10)
        while self.failed_attempts[ip] and self.failed_attempts[ip][0] < cutoff:
            self.failed_attempts[ip].popleft()
    
    def add_suspicious_ip(self, ip: str, reason: str):
        """의심스러운 IP 추가"""
        self.suspicious_ips.add(ip)
        self.security_alerts.append({
            'type': 'ip_blocked',
            'ip': ip,
            'reason': reason,
            'timestamp': datetime.now().isoformat()
        })
    
    def generate_security_report(self) -> Dict:
        """보안 리포트 생성"""
        recent_threats = list(self.security_alerts)[-50:]  # 최근 50개
        
        threat_summary = defaultdict(int)
        severity_summary = defaultdict(int)
        
        for threat in recent_threats:
            threat_type = threat.get('type', 'unknown')
            severity = threat.get('severity', 'low')
            threat_summary[threat_type] += 1
            severity_summary[severity] += 1
        
        return {
            'summary': {
                'total_threats': len(recent_threats),
                'suspicious_ips': len(self.suspicious_ips),
                'failed_attempts_ips': len(self.failed_attempts)
            },
            'threat_breakdown': dict(threat_summary),
            'severity_breakdown': dict(severity_summary),
            'recent_threats': recent_threats[-10:],  # 최근 10개
            'top_suspicious_ips': list(self.suspicious_ips)[:10],
            'generated_at': datetime.now().isoformat()
        }

# 전역 취약점 스캐너 인스턴스
vulnerability_scanner = VulnerabilityScanner()